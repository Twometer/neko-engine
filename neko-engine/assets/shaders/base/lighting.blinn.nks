#bind gPosition 0
#bind gNormal   1
#bind gAlbedo   2

#inject CameraMatrices
#inject CameraPosition
#inject ScreenSize

#begin vertex
    in vec3 position;
    out vec3 lightPos;
    out vec4 lightColor;
    out float lightConstant;
    out float lightLinear;
    out float lightQuadratic;

    uniform mat4 projectionMatrix;
    uniform mat4 viewMatrix;

    const int MAX_LIGHTS = 32;
    uniform mat4 modelMatrices[MAX_LIGHTS];
    uniform vec3 lightPositions[MAX_LIGHTS];
    uniform vec4 lightColors[MAX_LIGHTS];
    uniform vec3 lightValues[MAX_LIGHTS];

    void main(void) {
        gl_Position = projectionMatrix * viewMatrix * modelMatrices[gl_InstanceID] * vec4(position, 1.0f);

        // Unpack light values
        lightPos = lightPositions[gl_InstanceID];
        lightColor = lightColors[gl_InstanceID];

        vec3 val = lightValues[gl_InstanceID];
        lightConstant = val.x;
        lightLinear = val.y;
        lightQuadratic = val.z;
    }
#end vertex

#begin fragment
    in vec3 lightPos;
    in vec4 lightColor;
    in float lightConstant;
    in float lightLinear;
    in float lightQuadratic;
    out vec4 color;

    uniform vec2 screenSize;
    uniform vec3 cameraPos;

    uniform sampler2D gPosition;
    uniform sampler2D gNormal;
    uniform sampler2D gAlbedo;

    void main() {
        vec2 texCoords = gl_FragCoord.xy / screenSize;

        // Unpack GBuffer
        vec4 normalSpec = texture(gNormal, texCoords);
        vec4 albedoShine = texture(gAlbedo, texCoords);
        vec3 position = texture(gPosition, texCoords).xyz;
        vec3 normal = normalSpec.xyz;
        vec3 albedo = albedoShine.rgb;
        float specularStrength = normalSpec.a;
        float shininess = albedoShine.a;

        // Light calculations
        vec3 lightDir = lightPos - position;
        float distance = length(lightDir);
        lightDir /= distance;

        vec3 viewDir = normalize(cameraPos - position);
        vec3 halfway = normalize(lightDir + viewDir);

        vec3 lightRgb = lightColor.rgb;
        vec3 diffuse = lightRgb * max(dot(normal, lightDir), 0.0f);
        vec3 specular = lightRgb * pow(max(dot(normal, halfway), 0.0), shininess);
        float attenuation = 1.0 / (lightConstant + lightLinear * distance + lightQuadratic * distance * distance);

        color = vec4(albedo * attenuation * (diffuse + specularStrength * specular), 1.0f);
    }

#end fragment