#bind gPosition 0
#bind gNormal   1
#bind gAlbedo   2

#inject CameraMatrices
#inject CameraPosition
#inject ScreenSize

#begin vertex
    in vec3 position;
    out vec3 lightPos;
    out vec4 lightColor;
    out float lightConstant;
    out float lightLinear;
    out float lightQuadratic;

    uniform mat4 projectionMatrix;
    uniform mat4 viewMatrix;

    // Each light is 112 bytes in size [4 * 28]
    // A UBO can store 64KB. 512 lights are 57KB.
    const int MAX_LIGHTS = 512;
    struct Light {
        mat4 matrix;        // 0..15
        vec4 color;         // 16..20
        vec4 position;      // 20..24
        float constant;     // 25
        float linear;       // 26
        float quadratic;    // 27
        float _padding;     // 28
    };
    layout (std140) uniform LightsBlock {
        Light lights[MAX_LIGHTS];
    };

    void main(void) {
        Light light = lights[gl_InstanceID];
        gl_Position = projectionMatrix * viewMatrix * light.matrix * vec4(position, 1.0f);

        // Send light information to fragment shader
        lightPos = light.position.xyz;
        lightColor = light.color;
        lightConstant = light.constant;
        lightLinear = light.linear;
        lightQuadratic = light.quadratic;
    }
#end vertex

#begin fragment
    in vec3 lightPos;
    in vec4 lightColor;
    in float lightConstant;
    in float lightLinear;
    in float lightQuadratic;
    out vec4 color;

    uniform vec2 screenSize;
    uniform vec3 cameraPos;

    uniform sampler2D gPosition;
    uniform sampler2D gNormal;
    uniform sampler2D gAlbedo;

    void main() {
        vec2 texCoords = gl_FragCoord.xy / screenSize;

        // Unpack GBuffer
        vec4 normalSpec = texture(gNormal, texCoords);
        vec4 albedoShine = texture(gAlbedo, texCoords);
        vec3 position = texture(gPosition, texCoords).xyz;
        vec3 normal = normalSpec.xyz;
        vec3 albedo = albedoShine.rgb;
        float specularStrength = normalSpec.a;
        float shininess = albedoShine.a;

        // Light calculations
        vec3 lightDir = lightPos - position;
        float distance = length(lightDir);
        lightDir /= distance;

        vec3 viewDir = normalize(cameraPos - position);
        vec3 halfway = normalize(lightDir + viewDir);

        vec3 lightRgb = lightColor.rgb;
        vec3 diffuse = lightRgb * max(dot(normal, lightDir), 0.0f);
        vec3 specular = lightRgb * pow(max(dot(normal, halfway), 0.0), shininess);
        float attenuation = 1.0 / (lightConstant + lightLinear * distance + lightQuadratic * distance * distance);

        color = vec4(albedo * attenuation * (diffuse + specularStrength * specular), 1.0f);
    }
#end fragment